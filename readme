c++异步io库

编译：
1、 如需使用redis模块，则cmake时需定义宏USE_ASYNC_REDIS。如：cmake .. -DUSE_ASYNC_REDIS=1
    redis模块依赖：libevent、hiredis_vip、hiredis库

2、 如需使用mongo模块，则cmake时需定义宏USE_ASYNC_MONGO。如：cmake .. -DUSE_ASYNC_MONGO=1
    monogo模块依赖: bson-1.0、mongoc-1.0库

3、 如需使用libcurl模块，则cmake时需定义宏USE_ASYNC_CURL。如：cmake .. -DUSE_ASYNC_CURL=1
    libcurl模块依赖: libcurl库

4、 如需使用mysql模块，则cmake时需定义宏USE_ASYNC_MYSQL。如：cmake .. -DUSE_ASYNC_MYSQL=1
    mysql模块依赖：mariadb库

5、 如需使用ipc模块，则cmake时需定义宏USE_IPC。如：cmake .. -DUSE_USE_IPC=1
    ipc模块依赖：zeromq库

5、cmake例子：
    1）根目录下执行：mkdir -p build
    2）cd build
    3）cmake .. -DUSE_ASYNC_CURL=1 -DUSE_ASYNC_REDIS=1 -DUSE_ASYNC_MONGO=1 -DUSE_ASYNC_MYSQL=1 -DUSE_USE_IPC=1 -DCMAKE_BUILD_TYPE=Debug

依赖库安装：
    如果库安装路径、链接版本、头文件等出现报错，可以根据编译环境调整 common/CMakeLists.txt文件

目录结构：
example
    example.cpp         ----> 测试用例
    CMakeLists.txt      ----> 编译文件

common                  ----> 库目录
    threads             ----> 线程池目录
        thread_pool.h   ----> 线程池类
    
    coroutine           ----> 协程目录
        coroutine_task.h/cpp ----> 协程池类文件
        coroutine.h/cpp ----> 协程
    
    async               ----> 异步库目录
        cpu             ----> 异步cpu运算实现
        curl            ----> 异步http实现
        mongo           ----> 异步mongo实现
        mysql           ----> 异步mysql实现
        redis           ----> 异步redis实现

    co_async            ----> 协程与异步io的结合

    co_bridge           ----> 协程io桥，提供各个协程io时需要调用的共同接口，算是一种协调者

    ipc                 ----> 提供进程间的通信，适合用于后端服务之间的通信。使用zeromq库作为实现者

    co_ipc              ----> 用以提供进程间通信时协程式的send接口


层次结构：co表示coroutine协程

                              co_async
            ________________________________________________
            |      |        |        |         |          |
        ____|      |        |        |         |          |_
       |           |        |        |         |           |
     co_redis   co_mongo   co_curl  co_cpu   co_mysql   parallel接口
       |           |        |        |         |           |
       |           |        |        |         |           |
async_redis  async_mongo async_curl async_cpu async_mysql  |
       |           |        |        |         |           |
       |           |        |        |         |           |
       -----------------------------------------------------
                                    |
                                    |
                        co_bridge、thread_pool(*可选用)      

线程池是选用模块，建议使用，能使异步io运行速度变快。
如果不使用，则由调用线程来驱动异步io的运行

example:
int main() {
    // 定义一个线程池对象
    ThreadPool tp;
    // 设置mysql的异步驱动由线程池来执行
    async::mysql::setThreadFunc([&tp](std::function<void()> f) {
            tp.enqueue(f);
    });
    sleep(2);
    std::cout << "begin..." << std::endl;

    int count = 0;
    for (int i = 0; i < 100; ++i) {
        // 启动一个协程任务
        CoroutineTask::doTask([i, &count](void*) {
            // 发起mysql访问，并挂起协程，mysql访问结束时，协程被唤醒
            int ret = co_async::mysql::execute("192.168.0.81|3306|test|game|game", "select * from mytest", [i, &count](int err, void* row, int row_idx, int, int affected_row) {
                // 操作结果
                if (err != 0) {
                    std::cout << "error:" << err << std::endl;
                }
                if (row_idx == 1) {
                    std::cout << ".........." << i << "........." << std::endl;
                }
                if (row_idx != 0) {
                    std::cout << ((char**)row)[0] << ", " << ((char**)row)[1] << std::endl;
                }
                if (row_idx == affected_row) {
                    count++;
                    if (count == 100) {
                        std::cout << "finish" << std::endl;
                    }
                }
            });
            // 检查访问状态，成功还是失败或超时
            if (ret != co_bridge::E_CO_RETURN_OK) {
                std::cout << "failed to mysql::execute|" << ret << std::endl;
            }
        }, 0);
    }
    
    while (true) {
        co_bridge::loop();
        usleep(10);
    }
    return 0;
}
